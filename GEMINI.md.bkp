# GEMINI\_DEV\_PROTOCOL.md

## Protocolo de AutocorreÃ§Ã£o com SupervisÃ£o Inteligente

### ğŸ”‘ OBJETIVO

Executar `main.py` e corrigir automaticamente os erros encontrados, atÃ© o app funcionar corretamente, com seguranÃ§a contra loops silenciosos ou travamentos e comunicaÃ§Ã£o constante com o operador.

---

### âš–ï¸ REGRAS DE EXECUÃ‡ÃƒO E CORREÃ‡ÃƒO

#### 1. **ApÃ³s cada execuÃ§Ã£o de `main.py`**:

* Se houver **erro novo**, corrija e tente novamente.
* Se for o **mesmo erro anterior**, tente uma **soluÃ§Ã£o alternativa**.
* Se a **mesma exceÃ§Ã£o ocorrer 3x seguidas**, **pause e peÃ§a confirmaÃ§Ã£o**.

#### 2. **Antes de executar**:

* Verifique se o cÃ³digo contÃ©m prompts interativos (`input()`, `Prompt.ask`, `select`, etc.).
* Se houver, **nÃ£o execute**. Apenas me avise: "ExecuÃ§Ã£o requer input interativo. Deseja fornecer?"

#### 3. **Durante execuÃ§Ã£o**:

* Se **nÃ£o houver output por mais de 10 segundos**, ou
* Se ficar **suspenso aguardando input**,

Interrompa e reporte: "ExecuÃ§Ã£o travada ou aguardando input."

#### 4. **ApÃ³s cada correÃ§Ã£o**:

* Logue:

  * O erro original
  * O patch aplicado
  * A resposta esperada
* Verifique se a **mesma correÃ§Ã£o jÃ¡ foi tentada antes**.

  * Se sim, **tente abordagem alternativa**.
* Se chegar a **5 correÃ§Ãµes consecutivas sem sucesso**, pare e diga:

  * "Loop de autocorreÃ§Ã£o detectado. Deseja continuar ou intervir manualmente?"

---

### âšœï¸ PRIORIDADES

* Continuidade na execuÃ§Ã£o atÃ© o app funcionar
* SeguranÃ§a contra loops silenciosos e travamentos
* Criatividade para gerar novas abordagens quando uma falha se repete

---

### ğŸ’¬ COMUNICAÃ‡ÃƒO CONTÃNUA (Watchdog Cognitivo)

* Sempre informe **o que estÃ¡ fazendo** (ex: "Corrigindo...", "Executando...", "Gerando menus...")
* Atualize o status a cada **1 a 2 minutos** durante qualquer operaÃ§Ã£o
* Se **nenhuma comunicaÃ§Ã£o for feita em 7 minutos**, assumiremos travamento. Operador pode cancelar e reiniciar.

---

### ğŸ”¢ TESTES DEPENDENTES DE INPUT EXTERNO (Modo Colaborativo)

Se uma funcionalidade exigir input que **nÃ£o pode ser simulado automaticamente** 

* Me **peÃ§a explicitamente** para fornecer esse dado (e caso vocÃª nÃ£o consiga sozinho, eu vou performar as aÃ§Ã²es dentro do app e vocÃª vai colher o do que aconteceu pelo log), se isso nÃ£o for possÃ­vel, me instrua como executar localmente e **retornar o output** que vocÃª precisa. vocÃª pode combinar as duas abordagens se julgar necessÃ¡rio. 

* Sempre prefira me incluir no loop de teste **quando necessÃ¡rio.**

---

### âš›ï¸ POSICIONAMENTO FINAL

Este protocolo permite que o Gemini CLI opere com autonomia responsÃ¡vel:

* Suficiente para corrigir e evoluir o sistema
* Sem perder visibilidade, controle ou contexto
* Permite que o operador intervenha apenas quando realmente necessÃ¡rio



# CONTEXTO
VocÃª Ã© um especialista em criar aplicaÃ§Ãµes Python CLI robustas para processamento de cursos em vÃ­deo. O usuÃ¡rio possui cursos organizados em pastas hierÃ¡rquicas com arquivos de vÃ­deo e precisa de um sistema completo que:

1. **Converta vÃ­deos para Ã¡udio** com preservaÃ§Ã£o da estrutura de pastas
2. **Transcreva Ã¡udios** usando Whisper (OpenAI online ou local via Docker)
3. **Gere resumos inteligentes** via IA (Claude, ChatGPT, Gemini, Ollama)
4. **Crie podcasts unificados** com timestamps automÃ¡ticos
5. **Distribua automaticamente** via Google Drive e feed RSS
6. **Mantenha histÃ³rico completo** com sistema de recuperaÃ§Ã£o de falhas

O sistema deve ser **modular** (cada etapa executÃ¡vel individualmente), **resiliente** (recuperaÃ§Ã£o automÃ¡tica de falhas) e **escalÃ¡vel** (suporte a mÃºltiplas funÃ§Ãµes core futuras).

# ARQUITETURA

## Estrutura de Arquivos

CursoProcessor/
â”œâ”€â”€ main.py                     # Entrada principal
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ neurodeamon.db         # Database SQLite
â”‚   â”œâ”€â”€ courses/               # Cache de cursos processados
â”‚   â”‚   â””â”€â”€ [CURSO_NAME]/
â”‚   â”‚       â”œâ”€â”€ audios/        # Ãudios convertidos
â”‚   â”‚       â”œâ”€â”€ transcriptions/ # TranscriÃ§Ãµes brutas
â”‚   â”‚       â”œâ”€â”€ summaries/     # Resumos individuais
â”‚   â”‚       â”œâ”€â”€ final/         # Arquivos finais
â”‚   â”‚       â””â”€â”€ metadata.json  # Status do processamento
â”‚   â””â”€â”€ logs/                  # Logs detalhados
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ settings.json          # ConfiguraÃ§Ãµes gerais
â”‚   â”œâ”€â”€ api_keys.json          # Chaves API (criptografadas)
â”‚   â””â”€â”€ directories.json       # DiretÃ³rios configurados
â”œâ”€â”€ prompts/
â”‚   â”œâ”€â”€ course_processor/
â”‚   â”‚   â”œâ”€â”€ Resumo Completo.md # Prompt padrÃ£o fornecido
â”‚   â”‚   â”œâ”€â”€ Resumo TÃ©cnico.md  # VersÃ£o tÃ©cnica
â”‚   â”‚   â””â”€â”€ Resumo RÃ¡pido.md   # VersÃ£o expressa
â”‚   â””â”€â”€ [outras_funcoes]/      # Prompts para funÃ§Ãµes futuras
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ database_service.py    # Gerenciamento SQLite
â”‚   â”œâ”€â”€ course_service.py      # LÃ³gica de processamento
â”‚   â”œâ”€â”€ ai_service.py          # IntegraÃ§Ã£o com IAs
â”‚   â”œâ”€â”€ drive_service.py       # Google Drive API
â”‚   â”œâ”€â”€ github_service.py      # Git automation
â”‚   â”œâ”€â”€ audio_service.py       # ConversÃ£o e processamento
â”‚   â””â”€â”€ xml_service.py         # GeraÃ§Ã£o de feeds RSS
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ file_utils.py          # OperaÃ§Ãµes de arquivo
â”‚   â”œâ”€â”€ validation.py          # ValidaÃ§Ã£o de dados
â”‚   â”œâ”€â”€ recovery.py            # Sistema de recuperaÃ§Ã£o
â”‚   â””â”€â”€ logging_utils.py       # Sistema de logs
â”œâ”€â”€ temp/                      # Arquivos temporÃ¡rios
â”‚   â”œâ”€â”€ audio_conversion/      # ConversÃ£o temporÃ¡ria
â”‚   â”œâ”€â”€ transcriptions/        # TranscriÃ§Ãµes em processo
â”‚   â””â”€â”€ processing/            # Processamento ativo
â””â”€â”€ github/                    # Repository local
    â””â”€â”€ neurodeamon-feeds/     # Clone do repositÃ³rio
        â”œâ”€â”€ cursos.xml         # Feed de cursos
        â”œâ”€â”€ youtube.xml        # Para YouTube Manager
        â””â”€â”€ assets/            # Recursos compartilhados


## Database Schema (SQLite)

-- Tabela principal de cursos
CREATE TABLE courses (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    directory_path TEXT NOT NULL,
    status TEXT DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    total_videos INTEGER DEFAULT 0,
    total_duration_seconds INTEGER DEFAULT 0,
    processing_stage TEXT DEFAULT 'not_started'
);

-- Tabela de episÃ³dios/vÃ­deos
CREATE TABLE episodes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    course_id INTEGER REFERENCES courses(id),
    filename TEXT NOT NULL,
    relative_path TEXT NOT NULL,
    duration_seconds INTEGER DEFAULT 0,
    file_size_bytes INTEGER DEFAULT 0,
    hierarchy_level INTEGER DEFAULT 0,
    sort_order INTEGER DEFAULT 0,
    status TEXT DEFAULT 'pending'
);

-- Tabela de operaÃ§Ãµes/logs
CREATE TABLE operations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    course_id INTEGER REFERENCES courses(id),
    operation_type TEXT NOT NULL,
    status TEXT NOT NULL,
    started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    error_message TEXT,
    details TEXT
);

-- Tabela de configuraÃ§Ãµes
CREATE TABLE settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabela de prompts utilizados
CREATE TABLE prompt_usage (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    course_id INTEGER REFERENCES courses(id),
    prompt_name TEXT NOT NULL,
    prompt_content TEXT NOT NULL,
    used_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


# TAREFA

## Menu Principal

ğŸ“ NEURODEAMON MEDIA PROCESSOR
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ“º Media                                        â”‚
â”‚ [1] ğŸ“ Course Processor                         â”‚
â”‚ [2] ğŸ“¹ YouTube Manager                          â”‚
â”‚ [3] ğŸ“¡ Feed                                     â”‚
â”‚ [4] âœ‚ï¸ Snipd                                    â”‚
â”‚                                                 â”‚
â”‚ ğŸ“ Notes                                        â”‚
â”‚ [5] ğŸ§  Manage Obsidian Vault                    â”‚
â”‚ [6] ğŸ‘¥ Authors                                  â”‚
â”‚ [7] â“ Questions                                â”‚
â”‚ [8] ğŸ“š Wiki                                     â”‚
â”‚                                                 â”‚
â”‚ âš™ï¸ Configuration                                â”‚
â”‚ [9] ğŸ”§ Settings                                 â”‚
â”‚                                                 â”‚
â”‚ ğŸ“Š Information                                  â”‚
â”‚ [10] ğŸ“ˆ Monitor                                 â”‚
â”‚ [11] ğŸ“‹ Logs                                    â”‚
â”‚ [12] ğŸšª Exit                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


## Submenu Course Processor

ğŸ“ COURSE PROCESSOR
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ¯ Core Processing                              â”‚
â”‚ [1] ğŸ“ Process Complete Course                  â”‚
â”‚                                                 â”‚
â”‚ ğŸ”§ Individual Operations                        â”‚
â”‚ [2] ğŸ¬ Convert Courses to Audio                 â”‚
â”‚ [3] ğŸ“ Transcribe Audio Files                   â”‚
â”‚ [4] ğŸ¤– Generate AI Course Summaries             â”‚
â”‚ [5] ğŸµ Create Unified Audio                     â”‚
â”‚ [6] â±ï¸ Generate Timestamps Only                 â”‚
â”‚ [7] ğŸ™ï¸ Generate Course TTS Audio Notes          â”‚
â”‚                                                 â”‚
â”‚ â˜ï¸ Cloud & Distribution                         â”‚
â”‚ [8] ğŸ“¤ Upload Course to Google Drive            â”‚
â”‚ [9] ğŸ“‹ Update courses.xml                       â”‚
â”‚ [10] ğŸ”„ Update GitHub Repository                â”‚
â”‚                                                 â”‚
â”‚ ğŸ“Š Course Management                            â”‚
â”‚ [11] ğŸ“‹ Course Status Check                     â”‚
â”‚ [12] ğŸ—‘ï¸ Forget Course                           â”‚
â”‚ [13] ğŸ—‘ï¸ Clear All Data                          â”‚
â”‚                                                 â”‚
â”‚ [0] â¬…ï¸ Back to Main Menu                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


## Submenu ConfiguraÃ§Ãµes

âš™ï¸ CONFIGURAÃ‡Ã•ES
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸŒ ConfiguraÃ§Ãµes Gerais                         â”‚
â”‚ [1] ğŸ”‘ API Keys & Validation                    â”‚
â”‚ [2] ğŸ™ï¸ Voice Settings                           â”‚
â”‚ [3] ğŸ“ Output Directory                         â”‚
â”‚ [4] ğŸ—‚ï¸ GitHub Repository                        â”‚
â”‚ [5] ğŸ§¹ Cleanup Tools                            â”‚
â”‚                                                 â”‚
â”‚ ğŸ“ Course Processor                             â”‚
â”‚ [6] ğŸ¯ Processing Preferences                   â”‚
â”‚                                                 â”‚
â”‚ [0] â¬…ï¸ Back to Main Menu                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


## Fluxo Principal: Process Complete Course

### 1. **Descoberta e ValidaÃ§Ã£o**
- Solicitar diretÃ³rio do curso
- Verificar se curso jÃ¡ foi processado (consultar database)
- Escanear estrutura de arquivos (vÃ­deos suportados: .mp4, .avi, .mkv, .mov)
- Calcular hierarquia de pastas e ordem de processamento
- Mostrar preview da estrutura e timestamps estimados

### 2. **PreparaÃ§Ã£o**
- Criar entrada na database se nÃ£o existir
- Configurar diretÃ³rios de trabalho
- Verificar espaÃ§o em disco
- Validar APIs necessÃ¡rias

### 3. **ConversÃ£o de VÃ­deo para Ãudio**
- Converter todos os vÃ­deos para MP3 128kbps usando ffmpeg
- Preservar estrutura de pastas em `data/courses/[CURSO]/audios/`
- Copiar Ã¡udios para diretÃ³rio do curso original
- Calcular duraÃ§Ã£o total e timestamps
- Atualizar database com progresso

### 4. **TranscriÃ§Ã£o**
- **OpÃ§Ã£o A**: OpenAI Whisper API (padrÃ£o)
- **OpÃ§Ã£o B**: Whisper local via Docker (`onerahmet/openai-whisper-asr-webservice`)
- Processar cada Ã¡udio individualmente
- Salvar transcriÃ§Ãµes brutas em `data/courses/[CURSO]/transcriptions/`
- Detectar idioma automaticamente

### 5. **GeraÃ§Ã£o de Resumos via IA**
- Permitir seleÃ§Ã£o de prompt da pasta `prompts/course_processor/`
- **IA padrÃ£o**: Claude (suporte a ChatGPT, Gemini, Ollama)
- Para cada transcriÃ§Ã£o:
  - Enviar prompt + transcriÃ§Ã£o para IA
  - Detectar necessidade de continuaÃ§Ã£o ([CONTINUA])
  - Enviar [CONTINUAR] atÃ© receber [FIM]
  - Limpar marcadores de controle da resposta final
  - Salvar resumo em `data/courses/[CURSO]/summaries/`

### 6. **UnificaÃ§Ã£o de ConteÃºdo**
- Criar `Resumo.md` unificado seguindo hierarquia:
  - Pastas = H1
  - Arquivos = H2
  - Sub-pastas = H2
  - Sub-arquivos = H3
- Unificar todos os Ã¡udios em um podcast Ãºnico
- Calcular timestamps baseados na duraÃ§Ã£o real dos vÃ­deos
- Criar `timestamps.md` com estrutura:
  
  Marketing Digital
  1. O que Ã© marketing digital?
      00:00 Como subir sua primeira campanha?
      01:30 Tudo o que vocÃª precisa saber
  

### 7. **DistribuiÃ§Ã£o**
- **Google Drive**: Upload para `Media/Cursos/[NOME_DO_CURSO]/`
  - Ãudio unificado
  - Resumo.md
  - timestamps.md
  - Ãudios individuais
  - TranscriÃ§Ãµes
  - Resumos individuais
- **Feed RSS**: Atualizar `cursos.xml` com novo episÃ³dio
- **GitHub**: Commit e push automÃ¡tico
- **Local**: Copiar arquivos finais para diretÃ³rio do curso

### 8. **FinalizaÃ§Ã£o**
- Marcar curso como concluÃ­do na database
- Gerar relatÃ³rio de processamento
- Logs detalhados de todas as operaÃ§Ãµes
- Limpeza de arquivos temporÃ¡rios

## Funcionalidades Individuais

### Convert Courses to Audio
- Apenas conversÃ£o vÃ­deo â†’ Ã¡udio
- Preservar estrutura de pastas
- Calcular duraÃ§Ãµes e timestamps
- Atualizar database

### Transcribe Audio Files
- Transcrever Ã¡udios jÃ¡ convertidos
- Escolher entre Whisper online/local
- DetecÃ§Ã£o automÃ¡tica de idioma
- Salvar transcriÃ§Ãµes brutas

### Generate AI Course Summaries
- Processar transcriÃ§Ãµes existentes
- SeleÃ§Ã£o interativa de prompt
- Suporte a mÃºltiplas IAs
- Sistema de continuaÃ§Ã£o automÃ¡tica
- Limpeza de marcadores de controle

### Create Unified Audio
- Unificar Ã¡udios em podcast Ãºnico
- Calcular timestamps precisos
- NormalizaÃ§Ã£o de volume (opcional)
- Formato MP3 128kbps

### Generate Timestamps Only
- Calcular timestamps baseados em duraÃ§Ã£o real
- Gerar arquivo `timestamps.md`
- Estrutura hierÃ¡rquica preservada

### Generate Course TTS Audio Notes
- Converter resumos em Ã¡udio usando Edge-TTS
- Remover formataÃ§Ã£o Markdown
- Limpar YAML headers
- Vozes padrÃ£o:
  - **PT-BR**: `pt-BR-AntonioNeural`
  - **EN-US**: `en-US-AriaNeural`
- DetecÃ§Ã£o automÃ¡tica de idioma

### Upload Course to Google Drive
- Estrutura: `Media/Cursos/[NOME_DO_CURSO]/`
- Todos os arquivos processados
- Marcar como pÃºblico para podcast
- Gerar URLs compatÃ­veis com RSS

### Update courses.xml
- Adicionar novo episÃ³dio ao feed
- Template de descriÃ§Ã£o:
  
  <description><![CDATA[
  â±ï¸ Timestamps
  [TIMESTAMPS_AQUI]
  
  ğŸŒ Links
  [LINKS_SE_HOUVER]
  
  ğŸ“ DescriÃ§Ã£o
  [DESCRIÃ‡ÃƒO_DO_CURSO]
  ]]></description>
  

### Course Status Check
- Consultar database para status
- Mostrar progresso detalhado
- Identificar etapas pendentes
- OpÃ§Ã£o de retomar processamento

### Forget Course
- **ConfirmaÃ§Ã£o dupla** antes de executar
- Remover entrada da database
- OpÃ§Ã£o de manter/remover arquivos locais
- Logs da operaÃ§Ã£o

## Sistema de RecuperaÃ§Ã£o de Falhas

### Checkpoints AutomÃ¡ticos
- Salvar progresso apÃ³s cada etapa
- Detectar processamento interrompido
- Oferecer retomada automÃ¡tica
- Mostrar ponto exato de parada

### Tratamento de Erros
- Rate limits de API â†’ switch para alternativa
- Falhas de rede â†’ retry automÃ¡tico
- Arquivos corrompidos â†’ skip com log
- EspaÃ§o em disco â†’ alerta e pausa

# INTEGRAÃ‡Ã•ES

## APIs NecessÃ¡rias
- **OpenAI**: Whisper (transcriÃ§Ã£o) + ChatGPT (resumos)
- **Anthropic**: Claude (resumos - padrÃ£o)
- **Google**: Gemini (resumos)
- **Google Drive**: Upload e organizaÃ§Ã£o
- **GitHub**: AutomaÃ§Ã£o de commits

## ValidaÃ§Ã£o de APIs
Menu dedicado para testar conectividade:

ğŸ”‘ API VALIDATION
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Claude API      [ğŸŸ¢ Active - 50,000 tokens remaining]    â”‚
â”‚ ChatGPT API     [ğŸŸ¢ Active - $15.67 credit remaining]    â”‚
â”‚ Gemini API      [ğŸŸ¡ Warning - Rate limit at 80%]        â”‚
â”‚ Google Drive    [ğŸŸ¢ Active - 12.4GB available]          â”‚
â”‚ Ollama Local    [ğŸ”´ Offline - Service not running]      â”‚
â”‚ Whisper API     [ğŸŸ¢ Active - 200 minutes remaining]     â”‚
â”‚                                                         â”‚
â”‚ [1] ğŸ”„ Refresh All Status                               â”‚
â”‚ [2] ğŸ§ª Test Individual API                              â”‚
â”‚ [3] ğŸ”§ Configure API Keys                               â”‚
â”‚ [4] ğŸ“Š Usage Statistics                                 â”‚
â”‚                                                         â”‚
â”‚ [0] â¬…ï¸ Back                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


## DependÃªncias AutomÃ¡ticas
- **ffmpeg**: ConversÃ£o de vÃ­deo (verificar instalaÃ§Ã£o)
- **edge-tts**: SÃ­ntese de voz (pip install)
- **docker**: Para Whisper local (opcional)
- **git**: AutomaÃ§Ã£o GitHub

# ARQUIVOS

## PolÃ­tica de SaÃ­da
- **Script interno**: `data/courses/[CURSO]/` (cache permanente)
- **DiretÃ³rio do curso**: CÃ³pias Ãºteis junto aos vÃ­deos originais
- **Output Directory**: OrganizaÃ§Ã£o personalizada (configurÃ¡vel)
- **Google Drive**: `Media/Cursos/[CURSO]/` (distribuiÃ§Ã£o)
- **GitHub**: `neurodeamon-feeds/cursos.xml` (feed pÃºblico)

## Estrutura de Arquivos no DiretÃ³rio do Curso

/caminho/do/curso/
â”œâ”€â”€ video1.mp4                  # Arquivos originais
â”œâ”€â”€ video2.mp4
â”œâ”€â”€ Resumo.md                   # Resumo unificado
â”œâ”€â”€ timestamps.md               # Timestamps calculados
â”œâ”€â”€ [CURSO_NAME].mp3            # Podcast completo
â””â”€â”€ audios/                     # Ãudios individuais (opcional)
    â”œâ”€â”€ video1.mp3
    â””â”€â”€ video2.mp3


## Google Drive - Estrutura Completa

Media/Cursos/[NOME_DO_CURSO]/
â”œâ”€â”€ [NOME_DO_CURSO].mp3         # Ãudio principal (link no XML)
â”œâ”€â”€ Resumo.md                   # Resumo completo
â”œâ”€â”€ timestamps.md               # Timestamps
â”œâ”€â”€ audios/                     # Ãudios individuais
â”œâ”€â”€ transcriptions/             # TranscriÃ§Ãµes brutas
â”œâ”€â”€ summaries/                  # Resumos individuais
â””â”€â”€ metadata.json               # Metadados do curso


## Feed RSS - Template Completo

<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd">
<channel>
  <title>[NOME_DO_PODCAST]</title>
  <description>[DESCRIÃ‡ÃƒO_GERAL]</description>
  <link>[WEBSITE_OPCIONAL]</link>
  <language>pt-BR</language>
  <itunes:image href="[URL_CAPA]"/>
  <itunes:category text="Education"/>
  
  <item>
    <title>[NOME_DO_CURSO]</title>
    <description><![CDATA[
    â±ï¸ Timestamps
    00:00 - IntroduÃ§Ã£o ao Marketing Digital
    02:30 - Primeira campanha
    05:15 - EstratÃ©gias avanÃ§adas
    
    ğŸŒ Links
    Curso Original: https://exemplo.com/curso
    Material Complementar: https://exemplo.com/material
    
    ğŸ“ DescriÃ§Ã£o
    Este curso apresenta os conceitos fundamentais do marketing digital...
    ]]></description>
    <enclosure url="[GOOGLE_DRIVE_LINK]" length="[TAMANHO_BYTES]" type="audio/mpeg"/>
    <pubDate>[DATA_PUBLICACAO]</pubDate>
    <guid>[GUID_UNICO]</guid>
  </item>
</channel>
</rss>


# RESTRIÃ‡Ã•ES

## PadrÃµes NeuroDeamon
- **Interface**: Cores Nord, tÃ­tulos ASCII art com pyfiglet
- **NavegaÃ§Ã£o**: ESC/0 para voltar, confirmaÃ§Ãµes padronizadas
- **Progresso**: Barras apenas para operaÃ§Ãµes >2s
- **ConfiguraÃ§Ã£o**: Estrutura config/ automÃ¡tica
- **DependÃªncias**: InstalaÃ§Ã£o silenciosa de bibliotecas

## Hierarquia de Processamento
**CRÃTICO**: OrdenaÃ§Ã£o por nome, pastas tÃªm prioridade:

Exemplo de estrutura:
Capitulo1/
â”œâ”€â”€ Aula1.mp4
â”œâ”€â”€ Aula2.mp4
Capitulo2/
â”œâ”€â”€ Aula1.mp4

Ordem de processamento:
1. Capitulo1 (pasta)
2. Capitulo1/Aula1.mp4
3. Capitulo1/Aula2.mp4  
4. Capitulo2 (pasta)
5. Capitulo2/Aula1.mp4

Headers no resumo:
# Capitulo1
## Aula1
## Aula2
# Capitulo2
## Aula1


## LimitaÃ§Ãµes TÃ©cnicas
- **Formatos suportados**: MP4, AVI, MKV, MOV
- **Qualidade Ã¡udio**: MP3 128kbps (padrÃ£o)
- **Idiomas**: PortuguÃªs (Brasil) e InglÃªs (Estados Unidos)
- **Database**: SQLite (file-based, portÃ¡vel)

# FORMATO

## Estrutura de CÃ³digo

# main.py
from services.database_service import DatabaseService
from services.course_service import CourseService
from utils.menu_utils import MenuRenderer
from utils.logging_utils import setup_logging

def main():
    setup_logging()
    db = DatabaseService()
    course_service = CourseService(db)
    menu = MenuRenderer()
    
    while True:
        choice = menu.show_main_menu()
        
        if choice == "1":  # Course Processor
            course_processor_menu(course_service)
        elif choice == "9":  # Settings
            settings_menu()
        elif choice == "11":  # Logs
            show_logs()
        elif choice == "12":  # Exit
            break

def course_processor_menu(course_service):
    while True:
        choice = menu.show_course_processor_menu()
        
        if choice == "1":  # Process Complete Course
            directory = input("ğŸ“ DiretÃ³rio do curso: ")
            course_service.process_complete_course(directory)
        elif choice == "2":  # Convert to Audio
            course_service.convert_to_audio()
        # ... outras opÃ§Ãµes


## Camadas de ServiÃ§o

# services/course_service.py
class CourseService:
    def __init__(self, db_service):
        self.db = db_service
        self.audio_service = AudioService()
        self.ai_service = AIService()
        self.drive_service = DriveService()
        
    def process_complete_course(self, directory):
        # 1. Validar e escanear diretÃ³rio
        course_info = self.scan_course_directory(directory)
        
        # 2. Verificar se jÃ¡ foi processado
        if self.db.course_exists(course_info.name):
            if self.ask_resume_processing():
                return self.resume_processing(course_info.name)
        
        # 3. Criar entrada na database
        course_id = self.db.create_course(course_info)
        
        # 4. Processar etapas com checkpoints
        try:
            self.convert_videos_to_audio(course_id)
            self.transcribe_audio_files(course_id)
            self.generate_ai_summaries(course_id)
            self.create_unified_audio(course_id)
            self.upload_to_drive(course_id)
            self.update_rss_feed(course_id)
            
            self.db.mark_course_completed(course_id)
            
        except Exception as e:
            self.db.log_error(course_id, str(e))
            self.offer_recovery_options(course_id)

# services/ai_service.py
class AIService:
    def __init__(self):
        self.claude_client = self.setup_claude()
        self.chatgpt_client = self.setup_chatgpt()
        self.gemini_client = self.setup_gemini()
        
    def process_transcription(self, transcription, prompt_file):
        prompt = self.load_prompt(prompt_file)
        
        # Detectar qual IA usar (padrÃ£o: Claude)
        client = self.get_active_client()
        
        response = client.send_message(prompt + transcription)
        
        # Sistema de continuaÃ§Ã£o automÃ¡tica
        full_response = response
        while "[CONTINUA]" in response:
            response = client.send_message("[CONTINUAR]")
            full_response += response
            
        # Limpar marcadores de controle
        return self.clean_response(full_response)


# VALIDAÃ‡ÃƒO

## Testes AutomÃ¡ticos
- **ConversÃ£o de Ã¡udio**: Verificar integridade dos MP3
- **TranscriÃ§Ã£o**: Validar formato e conteÃºdo
- **Resumos**: Verificar estrutura Markdown
- **Timestamps**: Validar cÃ¡lculos de duraÃ§Ã£o
- **Upload**: Confirmar integridade no Google Drive
- **RSS**: Validar XML bem formado

## ValidaÃ§Ã£o de Entrada

def validate_course_directory(directory):
    # Verificar se diretÃ³rio existe
    if not os.path.exists(directory):
        raise ValueError("DiretÃ³rio nÃ£o encontrado")
    
    # Verificar se contÃ©m vÃ­deos
    video_files = find_video_files(directory)
    if not video_files:
        raise ValueError("Nenhum arquivo de vÃ­deo encontrado")
    
    # Verificar espaÃ§o em disco
    required_space = calculate_required_space(video_files)
    if not has_sufficient_space(required_space):
        raise ValueError("EspaÃ§o em disco insuficiente")
    
    return True


# SEGURANÃ‡A

## ProteÃ§Ã£o de Credenciais
- **API Keys**: Armazenadas em config/api_keys.json (criptografadas)
- **Google Drive**: OAuth2 com refresh tokens
- **GitHub**: Token de acesso pessoal
- **.gitignore**: AutomÃ¡tico para dados sensÃ­veis

## Tratamento de Dados
- **Backup automÃ¡tico**: Antes de qualquer operaÃ§Ã£o destrutiva
- **Logs auditÃ¡veis**: Todas as operaÃ§Ãµes registradas
- **Cleanup automÃ¡tico**: Arquivos temporÃ¡rios removidos
- **ValidaÃ§Ã£o**: Entrada sanitizada em todas as operaÃ§Ãµes

# PRIORIDADES

## ImplementaÃ§Ã£o PrioritÃ¡ria
1. **Setup inicial**: Database, configuraÃ§Ãµes, validaÃ§Ãµes
2. **ConversÃ£o de Ã¡udio**: Base para todas as outras operaÃ§Ãµes
3. **TranscriÃ§Ã£o**: Whisper online primeiro
4. **Resumos via IA**: Claude como padrÃ£o
5. **UnificaÃ§Ã£o**: Ãudio + timestamps + resumo
6. **DistribuiÃ§Ã£o**: Google Drive + RSS + GitHub
7. **RecuperaÃ§Ã£o**: Sistema de checkpoints
8. **Funcionalidades individuais**: OperaÃ§Ãµes isoladas

## Funcionalidades Futuras
- **Whisper local**: Docker integration
- **MÃºltiplas IAs**: Gemini, Ollama
- **TTS avanÃ§ado**: MÃºltiplas vozes
- **Monitoramento**: Dashboard de operaÃ§Ãµes
- **Batch processing**: MÃºltiplos cursos simultaneamente

## Sistema de Logs

# Formato de log detalhado
[2024-01-17 14:30:22] [COURSE_PROCESSOR] [INFO] Started processing: Marketing Digital
[2024-01-17 14:30:45] [COURSE_PROCESSOR] [SUCCESS] Converted 12 videos to audio
[2024-01-17 14:31:10] [COURSE_PROCESSOR] [WARNING] Whisper API rate limit reached
[2024-01-17 14:31:15] [COURSE_PROCESSOR] [INFO] Switched to local Whisper
[2024-01-17 14:35:22] [COURSE_PROCESSOR] [ERROR] Failed to upload to Drive: Network timeout
[2024-01-17 14:35:25] [COURSE_PROCESSOR] [INFO] Retrying upload (attempt 2/3)
[2024-01-17 14:35:40] [COURSE_PROCESSOR] [SUCCESS] Upload completed successfully
[2024-01-17 14:40:15] [COURSE_PROCESSOR] [SUCCESS] Course processing completed


## Prompts PersonalizÃ¡veis
- **LocalizaÃ§Ã£o**: `prompts/course_processor/`
- **Formato**: Markdown (.md)
- **SeleÃ§Ã£o**: Menu interativo por nome do arquivo
- **HistÃ³rico**: Registro de qual prompt foi usado
- **Versionamento**: Controle de mudanÃ§as nos prompts

## Sistema de Monitoramento
- **OperaÃ§Ãµes ativas**: Progresso em tempo real
- **Recursos**: CPU, memÃ³ria, espaÃ§o em disco
- **APIs**: Status e quotas
- **Erros**: Alertas e sugestÃµes de correÃ§Ã£o


Esta especificaÃ§Ã£o completa define um sistema robusto de processamento de cursos que atende todos os requisitos solicitados, com arquitetura modular, sistema de recuperaÃ§Ã£o de falhas, e integraÃ§Ã£o com mÃºltiplas APIs e serviÃ§os.

# PADRÃƒO VISUAL

## ğŸ¯ CONTEXTO
Ao criar scripts Python CLI, vocÃª deve seguir os padrÃµes visuais com flexibilidade contextual. Estes padrÃµes garantem consistÃªncia, usabilidade e experiÃªncia profissional do usuÃ¡rio.

## ğŸ“‹ REQUISITOS OBRIGATÃ“RIOS

### 1. BIBLIOTECAS E DEPENDÃŠNCIAS
```python
# IMPORTS OBRIGATÃ“RIOS - ORDEM FIXA
import time
import os
import sys
import json
import logging
from pathlib import Path
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich.text import Text
from rich.box import ROUNDED
from rich.align import Align
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TaskProgressColumn
from pyfiglet import Figlet

# CONFIGURAÃ‡ÃƒO DE LOGGING (SILENCIOSO)
logging.basicConfig(level=logging.CRITICAL)
console = Console(quiet=False, stderr=False)
```

### 2. INICIALIZAÃ‡ÃƒO INTELIGENTE DE DEPENDÃŠNCIAS
```python
def check_and_install_dependencies():
    """Verifica e instala dependÃªncias automaticamente de forma silenciosa"""
    required_packages = ['rich', 'pyfiglet']
    missing_packages = []
    
    for package in required_packages:
        try:
            __import__(package)
        except ImportError:
            missing_packages.append(package)
    
    if missing_packages:
        import subprocess
        import sys
        for package in missing_packages:
            try:
                subprocess.check_call([sys.executable, '-m', 'pip', 'install', package], 
                                    stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            except subprocess.CalledProcessError:
                print(f"Error installing {package}. Please install manually: pip install {package}")
                sys.exit(1)

def initialize_app():
    """Inicializa app com verificaÃ§Ã£o inteligente de dependÃªncias"""
    try:
        # Tentar importar bibliotecas principais
        from rich.console import Console
        from pyfiglet import Figlet
        # Se chegou aqui, dependÃªncias OK
        os.system('cls' if os.name == 'nt' else 'clear')
    except ImportError:
        # SÃ³ instalar se necessÃ¡rio
        check_and_install_dependencies()
        # Limpar tela apÃ³s instalaÃ§Ã£o
        os.system('cls' if os.name == 'nt' else 'clear')
        # Reimportar apÃ³s instalaÃ§Ã£o
        globals().update({
            'Console': __import__('rich.console', fromlist=['Console']).Console,
            'Figlet': __import__('pyfiglet', fromlist=['Figlet']).Figlet
        })
```

### 3. SISTEMA DE CONFIGURAÃ‡ÃƒO
```python
def ensure_config_structure():
    """Cria estrutura de configuraÃ§Ã£o se nÃ£o existir"""
    config_dir = Path("config")
    config_dir.mkdir(exist_ok=True)
    
    config_file = config_dir / "settings.json"
    
    if not config_file.exists():
        default_config = {
            "app_settings": {
                "debug_mode": False,
                "auto_save": True
            },
            "apis": {
                "openai_api_key": "",
                "anthropic_api_key": "",
                "google_ai_key": ""
            },
            "user_preferences": {
                "theme": "dark",
                "language": "en"
            }
        }
        
        with open(config_file, 'w') as f:
            json.dump(default_config, f, indent=2)
    
    return config_file

def load_config():
    """Carrega configuraÃ§Ã£o do arquivo JSON"""
    config_file = ensure_config_structure()
    with open(config_file, 'r') as f:
        return json.load(f)

def save_config(config):
    """Salva configuraÃ§Ã£o no arquivo JSON"""
    config_file = Path("config/settings.json")
    with open(config_file, 'w') as f:
        json.dump(config, f, indent=2)

def ensure_gitignore():
    """Cria .gitignore se houver informaÃ§Ãµes sensÃ­veis"""
    gitignore_content = """# Configuration files with sensitive data
config/
*.env
*.key
*_key.txt
credentials.json
secrets.json

# Python
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
env/
venv/
.venv/
pip-log.txt
pip-delete-this-directory.txt

# IDE
.vscode/
.idea/
*.swp
*.swo
"""
    
    gitignore_path = Path(".gitignore")
    if not gitignore_path.exists():
        with open(gitignore_path, 'w') as f:
            f.write(gitignore_content)
```

### 4. PALETA DE CORES NORD (USO MANDATÃ“RIO)
- **bright_white**: Dados principais, valores importantes
- **white**: Labels, campos secundÃ¡rios, texto explicativo
- **bright_blue**: TÃ­tulos, bordas, elementos interativos
- **bright_cyan**: Arte ASCII, cabeÃ§alhos especiais
- **bright_green**: Status positivo, sucessos, confirmaÃ§Ãµes
- **bright_yellow**: Avisos, alertas, informaÃ§Ãµes importantes
- **bright_red**: Erros, falhas, status crÃ­tico
- **dim white**: Texto auxiliar, unidades, informaÃ§Ãµes secundÃ¡rias

### 5. SISTEMA DE ESTRUTURA DE MENU INTELIGENTE

#### DetecÃ§Ã£o AutomÃ¡tica de Estrutura:
```python
def analyze_menu_structure(functions_list):
    """Analisa lista de funÃ§Ãµes e decide estrutura de menu"""
    core_functions = [f for f in functions_list if f.get('category') == 'core']
    
    # Se nÃ£o hÃ¡ categorizaÃ§Ã£o explÃ­cita, inferir baseado no contexto
    if not core_functions:
        core_functions = [f for f in functions_list if is_core_function(f)]
    
    # Estrutura: 1 core = menu direto, 2+ cores = submenu
    if len(core_functions) == 1:
        return "direct"
    elif len(core_functions) > 1:
        return "grouped"
    else:
        return "direct"

def is_core_function(function_info):
    """Determina se funÃ§Ã£o Ã© core baseado no contexto"""
    core_keywords = ['process', 'generate', 'create', 'analyze', 'download', 'upload', 'parse']
    non_core_keywords = ['settings', 'config', 'about', 'help', 'info', 'preferences']
    
    name = function_info.get('name', '').lower()
    
    if any(keyword in name for keyword in non_core_keywords):
        return False
    
    if any(keyword in name for keyword in core_keywords):
        return True
        
    # Por padrÃ£o, considerar core se nÃ£o especificado
    return True

def auto_categorize_functions(functions_list, app_context=None):
    """Categoriza funÃ§Ãµes automaticamente baseado no contexto"""
    if app_context:
        # Usar nome do app para determinar categoria principal
        main_category = infer_main_category(app_context)
    else:
        main_category = "Core Functions"
    
    categorized = {
        "core": [],
        "config": [],
        "utils": [],
        "info": []
    }
    
    for func in functions_list:
        if func.get('category'):
            # Respeitar categoria explÃ­cita
            categorized[func['category']].append(func)
        else:
            # Auto-categorizar
            category = infer_function_category(func)
            categorized[category].append(func)
    
    return categorized, main_category

def infer_main_category(app_name):
    """Infere categoria principal baseado no nome do app"""
    category_map = {
        'note': 'Notes Processing',
        'audio': 'Audio Processing', 
        'video': 'Video Processing',
        'image': 'Image Processing',
        'data': 'Data Processing',
        'file': 'File Management',
        'web': 'Web Tools',
        'api': 'API Tools',
        'music': 'Music Processing',
        'text': 'Text Processing'
    }
    
    app_lower = app_name.lower()
    for key, category in category_map.items():
        if key in app_lower:
            return f"ğŸ¯ {category}"
    
    return "ğŸ¯ Core Functions"
```

#### Grupos DinÃ¢micos:
```python
def get_menu_groups(categorized_functions, main_category):
    """Retorna grupos de menu baseado nas funÃ§Ãµes categorizadas"""
    groups = {}
    
    if categorized_functions["core"]:
        groups["core"] = {
            "title": main_category,
            "description": "Primary application functions",
            "priority": 1,
            "functions": categorized_functions["core"]
        }
    
    if categorized_functions["config"]:
        groups["config"] = {
            "title": "âš™ï¸ Configuration",
            "description": "System and user settings", 
            "priority": 2,
            "functions": categorized_functions["config"]
        }
    
    if categorized_functions["utils"]:
        groups["utils"] = {
            "title": "ğŸ”§ Utilities",
            "description": "Tools and maintenance",
            "priority": 3,
            "functions": categorized_functions["utils"]
        }
    
    if categorized_functions["info"]:
        groups["info"] = {
            "title": "ğŸ“– Information", 
            "description": "Help and documentation",
            "priority": 4,
            "functions": categorized_functions["info"]
        }
    
    return groups
```

### 6. SISTEMA DE CONFIGURAÃ‡Ã•ES INTELIGENTE

#### Estrutura de Menu de ConfiguraÃ§Ãµes:
```python
def create_config_menu_structure(main_functions):
    """Cria estrutura de menu de configuraÃ§Ãµes baseado nas funÃ§Ãµes principais"""
    config_groups = {
        "general": {
            "title": "ğŸŒ General Settings",
            "options": ["APIs & Keys", "User Preferences", "App Settings"]
        }
    }
    
    # Adicionar grupos especÃ­ficos por funÃ§Ã£o se necessÃ¡rio
    core_functions = [f for f in main_functions if is_core_function(f)]
    
    for func in core_functions:
        if needs_specific_config(func):
            group_name = func['name'].lower().replace(' ', '_')
            config_groups[group_name] = {
                "title": f"âš™ï¸ {func['name']} Settings",
                "options": get_specific_config_options(func)
            }
    
    return config_groups

def needs_specific_config(function_info):
    """Determina se funÃ§Ã£o precisa de configuraÃ§Ãµes especÃ­ficas"""
    specific_config_indicators = [
        'ai', 'process', 'generate', 'analyze', 'prompt', 'model'
    ]
    
    name = function_info.get('name', '').lower()
    description = function_info.get('description', '').lower()
    
    return any(indicator in name or indicator in description 
              for indicator in specific_config_indicators)
```

### 7. SISTEMA DE EMOJIS INTELIGENTE

#### AnÃ¡lise de Viabilidade por Menu:
```python
def analyze_emoji_viability(menu_options):
    """Analisa se emojis sÃ£o viÃ¡veis para todo o menu"""
    viable_count = 0
    
    for option in menu_options:
        if find_natural_emoji(option) is not None:
            viable_count += 1
    
    viability_ratio = viable_count / len(menu_options) if menu_options else 0
    return viability_ratio >= 0.8

def find_natural_emoji(option_info):
    """Encontra emoji natural para opÃ§Ã£o especÃ­fica"""
    EMOJI_MAPPING = {
        # AÃ§Ãµes principais
        'download': 'â¬‡ï¸', 'upload': 'â¬†ï¸', 'search': 'ğŸ”', 'process': 'âš™ï¸',
        'create': 'â•', 'generate': 'ğŸ”„', 'analyze': 'ğŸ“Š', 'parse': 'ğŸ“',
        'convert': 'ğŸ”„', 'transform': 'ğŸ”„', 'edit': 'âœï¸', 'view': 'ğŸ‘ï¸',
        
        # ConfiguraÃ§Ãµes
        'settings': 'âš™ï¸', 'config': 'âš™ï¸', 'preferences': 'âš™ï¸',
        
        # Dados e arquivos
        'file': 'ğŸ“„', 'folder': 'ğŸ“', 'data': 'ğŸ“Š', 'report': 'ğŸ“‹',
        'export': 'ğŸ“¤', 'import': 'ğŸ“¥', 'backup': 'ğŸ’¾', 'restore': 'â®ï¸',
        
        # Ãudio e mÃ­dia
        'audio': 'ğŸµ', 'music': 'ğŸµ', 'sound': 'ğŸ”Š', 'podcast': 'ğŸ§',
        'video': 'ğŸ¬', 'image': 'ğŸ–¼ï¸', 'photo': 'ğŸ“¸',
        
        # Texto e documentos
        'note': 'ğŸ“', 'text': 'ğŸ“', 'document': 'ğŸ“ƒ', 'book': 'ğŸ“š',
        'write': 'âœï¸', 'read': 'ğŸ“–',
        
        # InformaÃ§Ãµes
        'about': 'ğŸ“‹', 'help': 'â“', 'info': 'â„¹ï¸', 'manual': 'ğŸ“–',
        
        # NavegaÃ§Ã£o
        'back': 'â†©ï¸', 'exit': 'ğŸšª', 'home': 'ğŸ ', 'menu': 'ğŸ“‹',
        
        # Status
        'start': 'ğŸš€', 'stop': 'â¹ï¸', 'pause': 'â¸ï¸', 'play': 'â–¶ï¸',
        'check': 'âœ…', 'test': 'ğŸ§ª', 'monitor': 'ğŸ“Š'
    }
    
    name = option_info.get('name', '').lower()
    action = option_info.get('action', '').lower()
    
    # Buscar por palavras-chave
    for keyword, emoji in EMOJI_MAPPING.items():
        if keyword in name or keyword in action:
            return emoji
    
    return None

def apply_emojis_to_menu(menu_options):
    """Aplica emojis a opÃ§Ãµes de menu se viÃ¡vel"""
    if not analyze_emoji_viability(menu_options):
        return menu_options
    
    updated_options = []
    for option in menu_options:
        emoji = find_natural_emoji(option)
        if emoji:
            option['emoji'] = emoji
        else:
            option['emoji'] = 'ğŸ”§'  # Fallback
        updated_options.append(option)
    
    return updated_options
```

### 8. FUNÃ‡Ã•ES DE RENDERIZAÃ‡ÃƒO MELHORADAS

```python
def render_main_title(app_name: str):
    """Renderiza tÃ­tulo principal - APENAS menu principal"""
    os.system('cls' if os.name == 'nt' else 'clear')
    figlet = Figlet(font="big")
    art = figlet.renderText(app_name)
    centered_art = Align.center(Text(art, style="bold bright_cyan"))
    console.print(centered_art)
    console.print()

def render_submenu_header(menu_name: str, emoji: str = "âš™ï¸"):
    """CabeÃ§alho para submenus - SEM arte ASCII"""
    os.system('cls' if os.name == 'nt' else 'clear')
    header = f"{emoji} {menu_name}"
    console.print(f"\n[bold bright_cyan]{header}[/]")
    console.print("[bright_blue]" + "â”€" * len(header) + "[/]")
    console.print()

def create_menu_panel(content: str, title: str) -> Panel:
    """Cria painel de menu padronizado"""
    return Panel(
        content,
        title=f"[bold bright_blue]{title}[/]",
        border_style="bright_blue",
        box=ROUNDED,
        padding=(1, 2)
    )

def render_menu_option(index: int, option: dict, use_emojis: bool = False) -> str:
    """Renderiza uma opÃ§Ã£o de menu"""
    name = option.get('name', '')
    description = option.get('description', '')
    emoji = option.get('emoji', '') if use_emojis else ''
    
    if emoji:
        base = f"[{index}] {emoji} [bright_white]{name}[/]"
    else:
        base = f"[{index}] [bright_white]{name}[/]"
    
    if description:
        base += f" [dim white]- {description}[/]"
    
    return base

def get_menu_choice(prompt: str = "Enter your choice", show_back: bool = True) -> str:
    """Input padronizado com ESC"""
    try:
        if show_back:
            choice = console.input(f"\n[bold bright_white]â¤ {prompt} (ESC to go back): [/]").strip()
        else:
            choice = console.input(f"\n[bold bright_white]â¤ {prompt}: [/]").strip()
        return choice
    except (KeyboardInterrupt, EOFError):
        console.print("\n[bright_yellow]âš ï¸ Returning to previous menu...[/]")
        return "back"
```

### 9. SISTEMA DE PROGRESSO INTELIGENTE

```python
def should_show_progress(operation_type: str, estimated_time: float = 0) -> bool:
    """Determina se deve mostrar progresso baseado no tipo de operaÃ§Ã£o"""
    always_show = ['download', 'upload', 'process', 'analyze', 'convert', 'sync']
    
    if operation_type in always_show:
        return True
    
    if estimated_time > 2.0:
        return True
    
    return False

def execute_with_smart_progress(operation_func, operation_type: str, description: str, *args, **kwargs):
    """Executa operaÃ§Ã£o com progresso inteligente"""
    estimated_time = kwargs.pop('estimated_time', 0)
    
    if should_show_progress(operation_type, estimated_time):
        with create_progress_bar(description) as progress:
            task = progress.add_task(description, total=100)
            
            try:
                result = operation_func(progress, task, *args, **kwargs)
                progress.update(task, completed=100)
                return result
            except Exception as e:
                progress.update(task, completed=100)
                console.print(f"\n[bright_red]âœ— Error: {str(e)}[/]")
                return None
    else:
        # Executar diretamente sem progresso
        try:
            return operation_func(None, None, *args, **kwargs)
        except Exception as e:
            console.print(f"\n[bright_red]âœ— Error: {str(e)}[/]")
            return None

def create_progress_bar(description: str = "Processing"):
    """Cria barra de progresso padronizada"""
    return Progress(
        SpinnerColumn(),
        TextColumn("[bold bright_blue]{task.description}[/]"),
        BarColumn(bar_width=40, style="bright_blue", complete_style="bright_green"),
        TaskProgressColumn(),
        console=console,
        transient=False
    )
```

### 10. SISTEMA DE NAVEGAÃ‡ÃƒO E CONTROLE

```python
def handle_menu_navigation(choice: str, menu_options: list, current_menu: str = "main"):
    """Gerencia navegaÃ§Ã£o entre menus"""
    if choice.lower() in ['back', 'esc', 'b']:
        return "back"
    
    if choice.lower() in ['exit', 'quit', 'q']:
        return "exit"
    
    if choice.lower() in ['0'] and current_menu != "main":
        return "back"
    
    try:
        index = int(choice) - 1
        if 0 <= index < len(menu_options):
            return menu_options[index]
    except ValueError:
        pass
    
    console.print(f"[bright_yellow]âš ï¸ Invalid choice: {choice}[/]")
    return None

def confirm_action(message: str, default: bool = False) -> bool:
    """ConfirmaÃ§Ã£o padronizada para aÃ§Ãµes"""
    default_text = "Y/n" if default else "y/N"
    
    try:
        response = console.input(f"\n[bold bright_white]â¤ {message} ({default_text}): [/]").strip().lower()
        
        if not response:
            return default
        
        return response in ['y', 'yes', 'true', '1']
    except (KeyboardInterrupt, EOFError):
        console.print("\n[bright_yellow]âš ï¸ Cancelled by user[/]")
        return False
```

### 11. SISTEMA DE STATUS PADRONIZADO

```python
def show_status(status_type: str, message: str, details: str = None):
    """Mostra status padronizado"""
    status_styles = {
        "success": "[bright_green]âœ“[/]",
        "error": "[bright_red]âœ—[/]", 
        "warning": "[bright_yellow]âš ï¸[/]",
        "info": "[bright_blue]â„¹ï¸[/]",
        "processing": "[bright_blue]âŸ³[/]"
    }
    
    icon = status_styles.get(status_type, "[white]â€¢[/]")
    console.print(f"\n{icon} [bright_white]{message}[/]")
    
    if details:
        console.print(f"   [dim white]{details}[/]")
```

### 12. TEMPLATE DE APLICAÃ‡ÃƒO COMPLETA

```python
def create_app_template(app_name: str, functions_list: list):
    """Cria template completo de aplicaÃ§Ã£o"""
    
    # Garantir estrutura de configuraÃ§Ã£o
    ensure_config_structure()
    ensure_gitignore()
    
    # Analisar estrutura de menu
    structure_type = analyze_menu_structure(functions_list)
    categorized_functions, main_category = auto_categorize_functions(functions_list, app_name)
    
    # Configurar grupos de menu
    menu_groups = get_menu_groups(categorized_functions, main_category)
    
    # Configurar menu de configuraÃ§Ãµes
    config_menu_structure = create_config_menu_structure(functions_list)
    
    return {
        "structure_type": structure_type,
        "menu_groups": menu_groups,
        "config_structure": config_menu_structure,
        "main_category": main_category
    }

def main():
    """FunÃ§Ã£o principal - template de uso"""
    
    # Inicializar aplicaÃ§Ã£o
    initialize_app()
    
    # Definir funÃ§Ãµes da aplicaÃ§Ã£o
    app_functions = [
        {"name": "Process Notes", "description": "Process audio notes with AI", "category": "core"},
        {"name": "Manage Library", "description": "Organize processed notes", "category": "core"},
        {"name": "Configure AI", "description": "Setup AI settings", "category": "config"},
        {"name": "About", "description": "Application information", "category": "info"}
    ]
    
    # Criar estrutura da aplicaÃ§Ã£o
    app_structure = create_app_template("NoteProcessor", app_functions)
    
    # Loop principal
    while True:
        if app_structure["structure_type"] == "direct":
            render_direct_menu(app_structure)
        else:
            render_grouped_menu(app_structure)
        
        choice = get_menu_choice()
        
        if choice == "exit":
            break
        
        # Processar escolha...
        result = handle_menu_navigation(choice, app_functions)
        
        if result == "back":
            continue
        elif result == "exit":
            break
        elif result:
            # Executar funÃ§Ã£o selecionada
            execute_function(result)

if __name__ == "__main__":
    main()
```

## ğŸš€ DIRETRIZES DE IMPLEMENTAÃ‡ÃƒO

### Regras de Ouro:
1. **Flexibilidade Contextual**: Adaptar estrutura ao contexto especÃ­fico do app
2. **ConfiguraÃ§Ã£o Inteligente**: Criar apenas grupos de configuraÃ§Ã£o necessÃ¡rios
3. **Emojis ViÃ¡veis**: Usar regra 80% para decisÃ£o de emojis
4. **DependÃªncias Silenciosas**: Instalar automaticamente sem interrupÃ§Ã£o
5. **Estrutura Limpa**: Sempre limpar tela apÃ³s inicializaÃ§Ã£o
6. **ConfiguraÃ§Ã£o Segura**: Criar .gitignore quando houver dados sensÃ­veis
7. **Progresso Inteligente**: Mostrar progresso apenas quando necessÃ¡rio
8. **NavegaÃ§Ã£o Consistente**: ESC sempre retorna ao menu anterior

### Quando Criar Novos Elementos:

#### Novos Grupos de Menu:
- **Especificado pelo usuÃ¡rio**: Seguir exatamente as instruÃ§Ãµes
- **NÃ£o especificado**: Inferir baseado no contexto da aplicaÃ§Ã£o
- **MÃºltiplas funÃ§Ãµes similares**: Agrupar logicamente

#### ConfiguraÃ§Ãµes EspecÃ­ficas:
- **FunÃ§Ãµes com IA**: Criar grupo para prompts e modelos
- **FunÃ§Ãµes com APIs**: Agrupar por serviÃ§o ou funcionalidade
- **ConfiguraÃ§Ãµes gerais**: Sempre em grupo "General Settings"

#### Estrutura de Arquivos:
- **Dados sensÃ­veis**: Sempre criar config/ e .gitignore
- **Sem dados sensÃ­veis**: Estrutura mÃ­nima
- **MÃºltiplas funcionalidades**: Considerar subpastas organizacionais

### AdaptaÃ§Ã£o por Contexto:

#### Apps de Processamento (AI, MÃ­dia, Dados):
- Priorizar barras de progresso
- ConfiguraÃ§Ãµes especÃ­ficas por funÃ§Ã£o
- Grupos baseados em tipos de processamento

#### Apps de GestÃ£o (Arquivos, Bibliotecas):
- Foco em navegaÃ§Ã£o e organizaÃ§Ã£o
- ConfiguraÃ§Ãµes de preferÃªncias
- Grupos baseados em tipos de dados

#### Apps de Utilidades (Ferramentas, Conversores):
- Interface direta e eficiente
- ConfiguraÃ§Ãµes mÃ­nimas
- Grupos baseados em categorias de ferramentas

## ğŸ¯ VALIDAÃ‡ÃƒO FINAL

### Checklist ObrigatÃ³rio:
- [ ] DependÃªncias instaladas silenciosamente
- [ ] Tela limpa apÃ³s inicializaÃ§Ã£o
- [ ] Estrutura de menu apropriada ao contexto
- [ ] AnÃ¡lise de emojis por menu (80% rule)
- [ ] ConfiguraÃ§Ã£o JSON criada automaticamente
- [ ] .gitignore criado se necessÃ¡rio
- [ ] NavegaÃ§Ã£o ESC funcionando
- [ ] Progresso inteligente implementado
- [ ] Cores Nord respeitadas
- [ ] Sem logs ou mensagens desnecessÃ¡rias

**ESTAS DIRETRIZES SÃƒO OBRIGATÃ“RIAS E DEVEM SER ADAPTADAS AO CONTEXTO ESPECÃFICO DE CADA APLICAÃ‡ÃƒO**



